<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multivariate Normality Testing via 3D Projections</title>
    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Libraries via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <!-- Toastify CSS & JS via CDN -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <style>
        #consoleOutput::-webkit-scrollbar { width: 8px; }
        #consoleOutput::-webkit-scrollbar-track { background: #1a202c; }
        #consoleOutput::-webkit-scrollbar-thumb { background-color: #718096; border-radius: 4px; border: 2px solid #1a202c; }
        #canvasContainer { position: relative; width: 100%; height: 0; padding-bottom: 75%; overflow: hidden; background-color: #e2e8f0; border-radius: 0.375rem; cursor: grab; transition: background-color 0.3s; }
        #canvasContainer:active { cursor: grabbing; }
        #canvasContainer canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .histogram-container { position: relative; min-height: 300px; height: 300px; }
        .histogram-container canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .spinner { display: inline-block; width: 1.25rem; height: 1.25rem; vertical-align: -0.25em; border: 0.2em solid currentColor; border-right-color: transparent; border-radius: 50%; animation: spin .75s linear infinite; margin-right: 0.5rem; }
        #loading { transition: opacity 0.3s; }
        #loading.hidden { opacity: 0; pointer-events: none; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.5s ease-out forwards; }
        /* Toastify Custom Styles (Optional) */
        .toastify { font-family: inherit; font-size: 0.875rem; padding: 12px 20px; border-radius: 0.375rem; }
        .toastify.on { opacity: 1; }
        .toastify-error { background: linear-gradient(to right, #ef4444, #dc2626); }
        .toastify-success { background: linear-gradient(to right, #22c55e, #16a34a); }
        .toastify-warning { background: linear-gradient(to right, #f97316, #ea580c); }
        .toastify-info { background: linear-gradient(to right, #3b82f6, #2563eb); }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans p-4 md:p-8 antialiased">
    <div class="max-w-7xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900 mb-2">Multivariate Normality Testing via 3D Projections</h1>
            <p class="text-base text-gray-600">This tool explores a projection-based method for assessing multivariate normality. It compares the distribution of ellipsoid fit errors (Mean Squared Error - MSE) from random 3D projections of a test dataset against the distribution obtained from a reference Multivariate Normal (MVN) dataset.</p>
        </header>

        <!-- Controls -->
        <div class="bg-white p-4 rounded-lg shadow-md mb-6">
            <h2 class="text-xl font-semibold mb-4">Controls & Configuration</h2>
             <div class="flex flex-wrap gap-3 items-center mb-4" id="buttonContainer">
                 <button id="generateButton" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition duration-150 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Generate Datasets</button>
                 <button id="testNormalButton" class="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded transition duration-150 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">Test Normal (Reference)</button>
                 <button id="testNonNormalButton" class="bg-yellow-500 hover:bg-yellow-600 text-black py-2 px-4 rounded transition duration-150 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-400">Test Non-Normal</button>
                 <!-- Test Uploaded button will be added dynamically -->
                 <button id="newProjection" class="bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-4 rounded transition duration-150 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">New Projection</button>
                 <button id="compareButton" class="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded transition duration-150 ease-in-out shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">Compare & Conclude</button>
                 <div id="loading" class="flex items-center text-gray-500 italic hidden ml-auto"> <!-- Use ml-auto -->
                      <div class="spinner"></div>
                      <span>Calculating...</span>
                  </div>
             </div>
             <div class="flex flex-wrap gap-x-6 gap-y-3 items-center text-sm border-t border-gray-200 pt-4">
                  <div><label for="numDimensions" class="font-medium text-gray-700 mr-1">Dimensions (N):</label><input type="number" id="numDimensions" min="3" max="500" value="100" class="w-20 p-1 border border-gray-300 rounded focus:ring-indigo-500 focus:border-indigo-500"></div>
                  <div><label for="numSamples" class="font-medium text-gray-700 mr-1">Samples:</label><input type="number" id="numSamples" min="100" max="10000" value="10000" class="w-24 p-1 border border-gray-300 rounded focus:ring-indigo-500 focus:border-indigo-500"></div>
                  <div><label for="numTests" class="font-medium text-gray-700 mr-1">Tests:</label><input type="number" id="numTests" min="10" max="20000" value="20000" class="w-20 p-1 border border-gray-300 rounded focus:ring-indigo-500 focus:border-indigo-500"></div>
                  <div class="flex-grow min-w-[250px]"><label for="csvUpload" class="font-medium text-gray-700 mr-2">Upload CSV (Numeric, No Header):</label><input type="file" id="csvUpload" accept=".csv,text/csv" class="text-sm file:mr-3 file:py-1 file:px-3 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer"></div>
                  <div class="flex items-center ml-auto"><input type="checkbox" id="showConsole" checked class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 mr-2"><label for="showConsole" class="font-medium text-gray-700">Show Details</label></div>
             </div>
        </div>

        <!-- Main Content Area -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6" style="min-height: 500px;"> <!-- Add min-height -->

            <!-- Visualization Column -->
            <div class="lg:col-span-2 space-y-6">
                <!-- 3D Visualization -->
                <div class="bg-white p-4 rounded-lg shadow-md">
                    <h3 class="text-lg font-semibold mb-3 text-gray-800">3D Projection Visualization <span class="text-sm font-normal text-gray-500">(Last Tested Projection)</span></h3>
                    <div id="canvasContainer"></div>
                </div>

                <!-- Histograms -->
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                     <div class="bg-white p-4 rounded-lg shadow-md">
                         <h3 class="text-lg font-semibold mb-3 text-gray-800">Reference (Normal) MSE Distribution</h3>
                         <div id="histogramContainerNormal" class="histogram-container">
                             <canvas id="histogramCanvasNormal"></canvas>
                         </div>
                     </div>
                      <div class="bg-white p-4 rounded-lg shadow-md">
                         <h3 class="text-lg font-semibold mb-3 text-gray-800">Test (Non-Normal/Uploaded) MSE Dist.</h3>
                         <div id="histogramContainerNonNormal" class="histogram-container">
                             <canvas id="histogramCanvasNonNormal"></canvas>
                         </div>
                     </div>
                 </div>
            </div>

            <!-- Explanation Column -->
            <div class="lg:col-span-1 bg-white p-4 rounded-lg shadow-md space-y-5" id="explanationPanel">
                 <h3 class="text-lg font-semibold text-gray-800">Methodology Explained</h3>
                 <p class="text-sm text-gray-600">This method leverages the property that **any linear projection of a multivariate normal (MVN) distribution is itself normal**. Departures from normality in the high-dimensional space often manifest as non-ellipsoidal shapes in lower-dimensional projections.</p>
                 <div><h4 class="font-semibold mb-1 text-sm text-gray-700">Workflow:</h4><ol class="list-decimal list-inside text-sm text-gray-600 space-y-1.5">
                    <li>Generate or upload N-dimensional data. The "Normal" dataset serves as a **reference** for comparison.</li>
                    <li>For a chosen dataset, repeatedly perform the following 'test':</li>
                    <ul class="list-disc list-inside ml-4 text-xs space-y-1">
                        <li>Randomly sample 3 dimensions.</li>
                        <li>Project the N-dimensional data onto these 3 dimensions.</li>
                        <li>Fit an ellipsoid to the 3D projected points (based on the sample covariance matrix).</li>
                        <li>Calculate a goodness-of-fit metric: the Mean Squared Error (MSE) between the points and the fitted ellipsoid surface.</li>
                    </ul>
                    <li>Collect the MSE values from many tests (e.g., 100+).</li>
                    <li>Compare the **distribution** of MSE values from the test dataset against the reference Normal dataset's MSE distribution using visualization (histograms) and a statistical test (Mann-Whitney U).</li>
                </ol></div>
                 <div><h4 class="font-semibold mb-1 text-sm text-gray-700">Statistical Rationale & Advantages:</h4><ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                    <li>**Dimensionality Reduction:** Avoids the "curse of dimensionality" inherent in many high-dimensional tests.</li>
                    <li>**Sensitivity:** Can detect various types of departures from multivariate normality (e.g., skewness, multimodality, non-linear dependencies) that affect projection shapes.</li>
                    <li>**Comparison-Based:** The conclusion relies on comparing the test distribution to a known normal reference, rather than an absolute threshold.</li>
                    <li>**Visualization:** Provides intuitive visual feedback through the 3D plot and MSE histograms.</li>
                 </ul></div>
                 <div><h4 class="font-semibold mb-1 text-sm text-gray-700">Generated Dataset Details:</h4><ul class="list-disc list-inside text-sm text-gray-600 space-y-1"><li id="descNormal"><strong>Normal:</strong> Generated from an N-dimensional standard MVN distribution.</li><li id="descNonNormal"><strong>Non-Normal:</strong> Generated from a mixture of two MVN distributions with slightly different means and covariances to introduce non-normality.</li><li>Sample counts > 5000 may impact browser performance.</li></ul></div>
                  <div><h4 class="font-semibold mb-1 text-sm text-gray-700">User Guide:</h4><ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
                    <li>Use "Generate Datasets" first (adjust N/Samples if needed).</li>
                    <li>Run "Test Normal" to establish the reference MSE distribution.</li>
                    <li>Run "Test Non-Normal" or Upload and Test your own data.</li>
                    <li>Use "Compare & Conclude" for statistical comparison.</li>
                    <li>The Mann-Whitney U test assesses if the two MSE distributions (Reference vs. Test) are significantly different. A low p-value (< 0.05) suggests a significant difference, implying the test data deviates from the reference normal.</li>
                    <li>"New Projection" shows another random 3D view of the *last dataset tested*.</li>
                </ul></div>
            </div>
        </div>

        <!-- Results Display -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div class="bg-white p-4 rounded-lg shadow-md">
                <h3 class="text-lg font-semibold mb-3 text-gray-800">Reference (Normal) Results</h3>
                <div class="grid grid-cols-2 gap-4 text-center">
                    <div class="bg-gray-100 p-3 rounded"><h4 class="text-xs font-medium text-gray-500 uppercase tracking-wider mb-1">Mean MSE</h4><p id="normalMeanMSE" class="text-xl font-semibold text-gray-900">-</p></div>
                    <div class="bg-gray-100 p-3 rounded"><h4 class="text-xs font-medium text-gray-500 uppercase tracking-wider mb-1">Std Dev MSE</h4><p id="normalStdMSE" class="text-xl font-semibold text-gray-900">-</p></div>
                </div>
            </div>
            <div class="bg-white p-4 rounded-lg shadow-md">
                <h3 class="text-lg font-semibold mb-3 text-gray-800">Test (Non-Normal/Uploaded) Results</h3>
                <div class="grid grid-cols-2 gap-4 text-center">
                    <div class="bg-gray-100 p-3 rounded"><h4 class="text-xs font-medium text-gray-500 uppercase tracking-wider mb-1">Mean MSE</h4><p id="nonNormalMeanMSE" class="text-xl font-semibold text-gray-900">-</p></div>
                    <div class="bg-gray-100 p-3 rounded"><h4 class="text-xs font-medium text-gray-500 uppercase tracking-wider mb-1">Std Dev MSE</h4><p id="nonNormalStdMSE" class="text-xl font-semibold text-gray-900">-</p></div>
                </div>
            </div>
        </div>

        <!-- Conclusion Panel -->
        <div id="conclusionContainer" class="mb-6"></div>

        <!-- Console Output -->
        <div id="consoleOutputContainer" class="bg-gray-800 text-gray-200 p-4 rounded-lg shadow-md transition-opacity duration-300 ease-in-out">
             <div class="flex justify-between items-center mb-2"><h3 class="text-lg font-semibold text-gray-100">Calculation Details</h3><button id="clearConsoleButton" class="text-xs bg-gray-600 hover:bg-gray-500 text-gray-200 px-2 py-1 rounded transition duration-150">Clear Log</button></div>
             <div id="consoleOutput" class="h-64 overflow-y-auto font-mono text-xs bg-gray-900 p-3 rounded"></div>
        </div>

    </div> <!-- End Max Width Container -->

    <script>
        // --- Configuration & Global Variables ---
        const VISUALIZATION_POINTS = 1000;
        let config = { dimensions: 100, samples: 10000, tests: 20000 };
        let normalData = [], nonNormalData = [], uploadedData = null;
        let uploadedDataInfo = { name: '', samples: 0, dimensions: 0 };
        let scene, camera, renderer, ellipsoidMesh, pointsObj;
        let histogramCharts = { normal: null, nonNormal: null };
        let currentDataset = null, currentDatasetType = null, currentProjection = null;
        let normalResults = null, nonNormalResults = null;
        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005, zoomSpeed = 1.1;

        // --- Toast Notification Helper ---
        function showToast(message, type = 'info') {
            let backgroundColor;
            let duration = 3000; // Default duration
            let stopOnFocus = true;

            switch (type) {
                case 'success':
                    backgroundColor = "linear-gradient(to right, #22c55e, #16a34a)"; // Green
                    break;
                case 'error':
                    backgroundColor = "linear-gradient(to right, #ef4444, #dc2626)"; // Red
                    duration = 6000; // Longer duration for errors
                    break;
                case 'warning':
                    backgroundColor = "linear-gradient(to right, #f97316, #ea580c)"; // Orange
                    duration = 5000;
                    break;
                case 'info':
                default:
                    backgroundColor = "linear-gradient(to right, #3b82f6, #2563eb)"; // Blue
                    break;
            }

            Toastify({
                text: message,
                duration: duration,
                close: type === 'error' || type === 'warning', // Show close button for error/warning
                gravity: "top", // `top` or `bottom`
                position: "right", // `left`, `center` or `right`
                stopOnFocus: stopOnFocus, // Prevents dismissing of toast on hover
                style: { background: backgroundColor },
                // onClick: function(){} // Callback after click
            }).showToast();
        }


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            readConfigFromUI(); init3DScene(); initHistograms();
            setupEventListeners(); initConsole(); updateExplanationText();
            console.log("App initialized. Ready.");
            showToast("App initialized. Generate datasets or upload CSV.", "info");
        });

        // --- Core Functions (readConfigFromUI, updateExplanationText, initConsole, setupEventListeners, init3DScene, onWindowResize, 3D Interaction Handlers) ---
        // (Largely unchanged - using collapsed versions from previous edit)
        function readConfigFromUI() { try { config.dimensions = parseInt(document.getElementById('numDimensions').value) || 100; config.samples = parseInt(document.getElementById('numSamples').value) || 10000; config.tests = parseInt(document.getElementById('numTests').value) || 20000; if (config.dimensions < 3) { console.warn("Dimensions must be at least 3."); config.dimensions = 3; document.getElementById('numDimensions').value = 3; } if (config.samples < 10) { console.warn("Samples must be at least 10."); config.samples = 10; document.getElementById('numSamples').value = 10; } if (config.tests < 10) { console.warn("Number of tests must be at least 10."); config.tests = 10; document.getElementById('numTests').value = 10; } } catch (e) { console.error("Error reading configuration from UI:", e); config = { dimensions: 100, samples: 10000, tests: 20000 }; } }
        function updateExplanationText() { document.getElementById('descNormal').innerHTML = `<strong>Normal:</strong> Generated from an N-dimensional standard MVN distribution (${config.dimensions}D, ${config.samples} samples).`; document.getElementById('descNonNormal').innerHTML = `<strong>Non-Normal:</strong> Generated from a mixture of two MVN distributions (${config.dimensions}D, ${config.samples} samples).`; }
        function initConsole() { const consoleOutput = document.getElementById('consoleOutput'); const consoleContainer = document.getElementById('consoleOutputContainer'); const showConsoleCheckbox = document.getElementById('showConsole'); const clearButton = document.getElementById('clearConsoleButton'); const toggleConsole = () => { consoleContainer.style.display = showConsoleCheckbox.checked ? 'block' : 'none'; }; showConsoleCheckbox.addEventListener('change', toggleConsole); clearButton.addEventListener('click', () => { consoleOutput.innerHTML = ''; }); toggleConsole(); const originalConsoleLog = console.log; console.log = function() { originalConsoleLog.apply(console, arguments); if (showConsoleCheckbox.checked) { const message = Array.from(arguments).map(arg => (typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg))).join(' '); const time = new Date().toLocaleTimeString(); const newLine = document.createElement('div'); newLine.innerHTML = `<span class="text-gray-500 mr-2">[${time}]</span> ${message.replace(/\n/g, '<br>')}`; newLine.className = 'whitespace-normal break-words mb-1'; consoleOutput.appendChild(newLine); consoleOutput.scrollTop = consoleOutput.scrollHeight; } }; const originalConsoleWarn = console.warn; console.warn = function() { originalConsoleWarn.apply(console, arguments); if (showConsoleCheckbox.checked) { const message = Array.from(arguments).map(arg => (typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg))).join(' '); const time = new Date().toLocaleTimeString(); const newLine = document.createElement('div'); newLine.innerHTML = `<span class="text-yellow-400 mr-2">[WARN ${time}]</span> <span class="text-yellow-300">${message.replace(/\n/g, '<br>')}</span>`; newLine.className = 'whitespace-normal break-words mb-1'; consoleOutput.appendChild(newLine); consoleOutput.scrollTop = consoleOutput.scrollHeight; } }; const originalConsoleError = console.error; console.error = function() { originalConsoleError.apply(console, arguments); if (showConsoleCheckbox.checked) { const message = Array.from(arguments).map(arg => (arg instanceof Error ? `${arg.name}: ${arg.message}\n${arg.stack}` : (typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)))).join(' '); const time = new Date().toLocaleTimeString(); const newLine = document.createElement('div'); newLine.innerHTML = `<span class="text-red-400 mr-2">[ERROR ${time}]</span> <span class="text-red-300">${message.replace(/\n/g, '<br>')}</span>`; newLine.className = 'whitespace-normal break-words mb-1'; consoleOutput.appendChild(newLine); consoleOutput.scrollTop = consoleOutput.scrollHeight; } }; }
        function setupEventListeners() { document.getElementById('generateButton').addEventListener('click', generateDatasets); document.getElementById('testNormalButton').addEventListener('click', () => testDataset('normal')); document.getElementById('testNonNormalButton').addEventListener('click', () => testDataset('nonNormal')); document.getElementById('newProjection').addEventListener('click', generateNewProjection); document.getElementById('compareButton').addEventListener('click', compareAndConclude); document.getElementById('csvUpload').addEventListener('change', handleFileUpload); document.getElementById('numDimensions').addEventListener('change', () => { readConfigFromUI(); updateExplanationText(); }); document.getElementById('numSamples').addEventListener('change', () => { readConfigFromUI(); updateExplanationText(); }); document.getElementById('numTests').addEventListener('change', readConfigFromUI); const canvasContainer = document.getElementById('canvasContainer'); canvasContainer.addEventListener('mousedown', onMouseDown); canvasContainer.addEventListener('mousemove', onMouseMove); canvasContainer.addEventListener('mouseup', onMouseUp); canvasContainer.addEventListener('mouseleave', onMouseUp); canvasContainer.addEventListener('wheel', onMouseWheel, { passive: false }); }
        function init3DScene() { const container = document.getElementById('canvasContainer'); if (!container) { console.error("Canvas container not found!"); return; } try { scene = new THREE.Scene(); scene.background = new THREE.Color(0xe2e8f0); const width = container.clientWidth; const height = container.clientHeight || (width * 0.75); camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000); camera.position.set(0, 0, 5); renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(width, height); renderer.setPixelRatio(window.devicePixelRatio); container.innerHTML = ''; container.appendChild(renderer.domElement); scene.add(new THREE.AmbientLight(0xcccccc, 0.7)); const dirLight = new THREE.DirectionalLight(0xffffff, 0.6); dirLight.position.set(5, 10, 7.5); scene.add(dirLight); const axesHelper = new THREE.AxesHelper(2); scene.add(axesHelper); function animate() { requestAnimationFrame(animate); if (scene && camera && renderer) { camera.lookAt(scene.position); renderer.render(scene, camera); } } animate(); window.addEventListener('resize', onWindowResize); onWindowResize(); } catch (error) { console.error("Error initializing 3D scene:", error); container.innerHTML = '<p class="absolute inset-0 flex items-center justify-center text-red-500">Error initializing 3D view. Check console.</p>'; } }
        function onWindowResize() { const container = document.getElementById('canvasContainer'); if (!container || !renderer || !camera) return; const width = container.clientWidth; const aspectRatio = 4 / 3; const height = width / aspectRatio; camera.aspect = width / height; camera.updateProjectionMatrix(); renderer.setSize(width, height); }
        function onMouseDown(event) { isDragging = true; previousMousePosition = { x: event.clientX, y: event.clientY }; event.currentTarget.style.cursor = 'grabbing'; }
        function onMouseMove(event) { if (!isDragging || !camera || !renderer) return; const deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y }; const deltaRotationQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(deltaMove.y * rotationSpeed, deltaMove.x * rotationSpeed, 0, 'YXZ')); camera.position.sub(scene.position); camera.position.applyQuaternion(deltaRotationQuaternion); camera.position.add(scene.position); previousMousePosition = { x: event.clientX, y: event.clientY }; }
        function onMouseUp(event) { isDragging = false; if (event.currentTarget) { event.currentTarget.style.cursor = 'grab'; } }
        function onMouseWheel(event) { event.preventDefault(); if (!camera) return; const zoomOut = event.deltaY > 0; const factor = zoomOut ? zoomSpeed : 1 / zoomSpeed; camera.position.sub(scene.position); camera.position.multiplyScalar(factor); camera.position.add(scene.position); camera.position.clampLength(1, 50); }

        function initHistograms() {
            const createChart = (canvasId, containerId) => {
                const ctx = document.getElementById(canvasId)?.getContext('2d');
                if (!ctx) { console.error(`Histogram canvas context '${canvasId}' not found!`); const container = document.getElementById(containerId); if(container) container.innerHTML = `<p class="text-red-500 p-4">Error loading histogram.</p>`; return null; }
                return new Chart(ctx, { type: 'bar', data: { labels: [], datasets: [{ label: 'MSE Distribution', data: [], backgroundColor: 'rgba(59, 130, 246, 0.7)', borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 1 }] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { title: { display: true, text: 'MSE Bins', font: { size: 10 } }, ticks: { font: { size: 9 } } }, y: { title: { display: true, text: 'Frequency' }, beginAtZero: true } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: c => ` Projections: ${c.parsed.y}` } } } } }); };
            histogramCharts.normal = createChart('histogramCanvasNormal', 'histogramContainerNormal');
            histogramCharts.nonNormal = createChart('histogramCanvasNonNormal', 'histogramContainerNonNormal');
        }

        // --- Data Generation ---
        function generateDatasets() {
            readConfigFromUI(); const loading = document.getElementById('loading');
            loading.classList.remove('hidden'); loading.style.opacity = 1;
            console.log(`Generating datasets: ${config.samples} samples, ${config.dimensions} dimensions.`);
            showToast(`Generating ${config.dimensions}D datasets...`, 'info');
            normalData = []; nonNormalData = []; uploadedData = null; normalResults = null; nonNormalResults = null;
            updateResultDisplay('normal', null); updateResultDisplay('nonNormal', null);
            clearConclusion(); clearVisualization(); removeUploadedDataButton();
            updateHistogram('normal', []); updateHistogram('nonNormal', []);
            setTimeout(() => { try {
                normalData = generateMultivariateNormal(config.dimensions, config.samples);
                nonNormalData = generateNonNormalData(config.dimensions, config.samples);
                console.log("Datasets generated successfully.");
                showToast(`Generated ${config.dimensions}D datasets (${config.samples} samples). Ready to test.`, 'success');
            } catch (error) { console.error("Error generating datasets:", error); showToast("Error generating datasets: " + error.message, 'error'); }
            finally { loading.classList.add('hidden'); loading.style.opacity = 0; } }, 50);
        }
        function generateMultivariateNormal(dims, samples) { /* ... unchanged ... */ console.log(`Generating ${samples} samples of ${dims}-dimensional normal data...`); const data = []; const logInterval = Math.max(100, Math.floor(samples / 10)); for (let i = 0; i < samples; i++) { const sample = new Array(dims); for (let j = 0; j < dims; j += 2) { const u1 = Math.random(); const u2 = Math.random(); const R = Math.sqrt(-2 * Math.log(Math.max(u1, 1e-10))); const theta = 2 * Math.PI * u2; sample[j] = R * Math.cos(theta); if (j + 1 < dims) sample[j + 1] = R * Math.sin(theta); } data.push(sample); if (i > 0 && i % logInterval === 0) console.log(` Generated ${i} normal samples...`); } console.log(`Finished generating ${samples} normal samples.`); return data; }
        function generateNonNormalData(dims, samples) { /* ... unchanged ... */ console.log(`Generating ${samples} samples of ${dims}-dimensional non-normal data (Mixture)...`); const data = []; const mixtureProb = 0.6; const meanShift = 0.7; const scale2 = 0.6; const logInterval = Math.max(100, Math.floor(samples / 10)); for (let i = 0; i < samples; i++) { const sample = new Array(dims); const isMixture1 = Math.random() < mixtureProb; const shift = isMixture1 ? 0 : meanShift; const scale = isMixture1 ? 1 : scale2; for (let j = 0; j < dims; j += 2) { const u1 = Math.random(); const u2 = Math.random(); const R = Math.sqrt(-2 * Math.log(Math.max(u1, 1e-10))); const theta = 2 * Math.PI * u2; sample[j] = (R * Math.cos(theta)) * scale + shift; if (j + 1 < dims) sample[j + 1] = (R * Math.sin(theta)) * scale + shift; } if (!isMixture1 && dims >= 3) { const influence = sample[0] * 0.1; sample[1] = sample[1] * 0.95 + influence; sample[2] = sample[2] * 0.95 + influence; } data.push(sample); if (i > 0 && i % logInterval === 0) console.log(` Generated ${i} non-normal samples...`); } console.log(`Finished generating ${samples} non-normal samples.`); return data; }

        // --- CSV Handling ---
        function handleFileUpload(event) { /* ... replaces alert with showToast ... */ const file = event.target.files[0]; const inputElement = event.target; if (!file) return; console.log(`Loading file: ${file.name} (Type: ${file.type}, Size: ${file.size} bytes)`); if (!file.type.includes('csv') && !file.name.toLowerCase().endsWith('.csv')) { showToast('Please upload a valid CSV file (.csv extension).', 'error'); inputElement.value = ''; return; } const loading = document.getElementById('loading'); loading.classList.remove('hidden'); loading.style.opacity = 1; showToast(`Parsing ${file.name}...`, 'info'); Papa.parse(file, { header: false, dynamicTyping: true, skipEmptyLines: true, fastMode: true, worker: true, complete: (results) => { loading.classList.add('hidden'); loading.style.opacity = 0; console.log("CSV parsing completed."); if (results.errors.length > 0) { console.error('PapaParse errors:', results.errors); showToast(`Error parsing CSV: ${results.errors.slice(0,3).map(e => e.message).join('; ')}. Check console.`, 'error'); inputElement.value = ''; return; } if (!results.data || results.data.length === 0) { showToast('CSV file appears empty or could not be parsed.', 'error'); inputElement.value = ''; return; } processUploadedData(results.data, file.name); inputElement.value = ''; }, error: (error) => { loading.classList.add('hidden'); loading.style.opacity = 0; console.error('PapaParse file reading error:', error); showToast('Error reading or parsing CSV file: ' + error.message, 'error'); inputElement.value = ''; } }); }
        function processUploadedData(data, fileName) { /* ... replaces alert with showToast ... */ console.log(`Processing uploaded data from ${fileName}...`); try { const samples = data.length; if (samples === 0) throw new Error("No data rows found."); const dimensions = data[0].length; if (dimensions === 0) throw new Error("No data columns found."); if (dimensions < 3) throw new Error(`Data must have at least 3 dimensions, found ${dimensions}.`); console.log(`CSV structure: ${samples} samples, ${dimensions} dimensions.`); let nonNumericCount = 0; const numericData = []; let inconsistentRows = 0; for (let i = 0; i < samples; i++) { const row = data[i]; if (row.length !== dimensions) { console.warn(`Skipping row ${i + 1}: Inconsistent number of columns (${row.length}, expected ${dimensions}).`); inconsistentRows++; continue; } const numericRow = new Array(dimensions); let rowHasNonNumeric = false; for (let j = 0; j < dimensions; j++) { const value = row[j]; if (typeof value === 'number' && isFinite(value)) { numericRow[j] = value; } else { const num = Number(value); if (typeof value === 'string' && value.trim() !== '' && isFinite(num)) { numericRow[j] = num; } else { numericRow[j] = 0; if (!rowHasNonNumeric) { nonNumericCount++; rowHasNonNumeric = true; } if (i < 10 && j < 10) { console.warn(`Replaced non-numeric value '${value}' with 0 at row ${i+1}, col ${j+1}.`); } } } } numericData.push(numericRow); } const finalSamples = numericData.length; if (finalSamples < 10) { throw new Error(`After cleaning, only ${finalSamples} valid samples remain. Need at least 10.`); } let warningMsg = ''; if (inconsistentRows > 0) { warningMsg += ` Skipped ${inconsistentRows} rows due to inconsistent column counts.`; } if (nonNumericCount > 0) { const nonNumericPercent = ((nonNumericCount / finalSamples) * 100).toFixed(1); warningMsg += ` Found non-numeric values in ${nonNumericCount} (${nonNumericPercent}%) rows; replaced with 0.`; } if (warningMsg) { showToast("Data Upload Warning:" + warningMsg + " Results might be affected.", 'warning'); console.warn("Data Upload Warning:", warningMsg); } uploadedData = numericData; uploadedDataInfo = { name: fileName, samples: finalSamples, dimensions: dimensions }; console.log(`Successfully processed uploaded data: ${finalSamples} samples, ${dimensions} dimensions.`); showToast(`Loaded ${fileName}: ${finalSamples} valid samples, ${dimensions} dimensions.`, 'success'); nonNormalResults = null; updateResultDisplay('nonNormal', null); clearConclusion(); clearVisualization(); updateHistogram('nonNormal', []); addUploadedDataButton(); } catch (error) { console.error('Error processing uploaded data:', error); showToast('Error processing data: ' + error.message, 'error'); uploadedData = null; uploadedDataInfo = { name: '', samples: 0, dimensions: 0 }; removeUploadedDataButton(); } }
        function addUploadedDataButton() { /* ... unchanged ... */ const container = document.getElementById('buttonContainer'); if (!container || document.getElementById('testUploadedButton')) return; const button = document.createElement('button'); button.id = 'testUploadedButton'; button.textContent = 'Test Uploaded'; button.className = 'bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded transition duration-150 ease-in-out order-3 md:order-none shadow-sm hover:shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500'; button.addEventListener('click', () => testDataset('uploaded')); const nonNormalButton = document.getElementById('testNonNormalButton'); if (nonNormalButton && nonNormalButton.nextSibling) { container.insertBefore(button, nonNormalButton.nextSibling); } else { container.appendChild(button); } console.log("Added 'Test Uploaded' button."); }
        function removeUploadedDataButton() { /* ... unchanged ... */ const button = document.getElementById('testUploadedButton'); if (button) button.remove(); }

        // --- Testing Logic ---
        function testDataset(type) { /* ... replaces alert with showToast ... */ readConfigFromUI(); const loading = document.getElementById('loading'); loading.classList.remove('hidden'); loading.style.opacity = 1; if (document.getElementById('showConsole').checked) { document.getElementById('consoleOutput').innerHTML = ''; } let dataset, datasetName, datasetDims, datasetSamples; try { if (type === 'normal') { if (!normalData || normalData.length === 0) throw new Error("Normal dataset not generated."); dataset = normalData; datasetName = 'NORMAL'; } else if (type === 'nonNormal') { if (!nonNormalData || nonNormalData.length === 0) throw new Error("Non-Normal dataset not generated."); dataset = nonNormalData; datasetName = 'NON-NORMAL'; } else if (type === 'uploaded') { if (!uploadedData || uploadedData.length === 0) throw new Error("No data uploaded or processed."); dataset = uploadedData; datasetName = `UPLOADED (${uploadedDataInfo.name})`; } else { throw new Error('Invalid dataset type specified.'); } datasetDims = dataset[0].length; datasetSamples = dataset.length; if (datasetSamples < 10 || datasetDims < 3) { throw new Error(`Dataset must have at least 10 samples and 3 dimensions. Found: ${datasetSamples}x${datasetDims}`); } } catch (error) { showToast(`Cannot test ${type}: ${error.message}`, 'error'); console.error(`Pre-test check failed for ${type}:`, error); loading.classList.add('hidden'); loading.style.opacity = 0; return; } currentDataset = dataset; currentDatasetType = type; if (type === 'normal') { normalResults = null; updateResultDisplay('normal', null); updateHistogram('normal', []); } else { nonNormalResults = null; updateResultDisplay('nonNormal', null); updateHistogram('nonNormal', []); } clearConclusion(); clearVisualization(); console.log(`\n========== TESTING ${datasetName} DATASET ==========`); console.log(` Dimensions: ${datasetDims}, Samples: ${datasetSamples}, Tests: ${config.tests}`); showToast(`Testing ${datasetName} (${config.tests} projections)...`, 'info'); const mseValues = []; const chunkSize = Math.min(50, Math.ceil(config.tests / 10)); let testsDone = 0; let projectionForVis = null; function processChunk() { const start = Date.now(); const chunkStartIdx = testsDone; const chunkEndIdx = Math.min(testsDone + chunkSize, config.tests); let chunkFailedFits = 0; for (let test = chunkStartIdx; test < chunkEndIdx; test++) { const dims = getRandomDimensions(datasetDims, 3); const projection = dataset.map(sample => [sample[dims[0]], sample[dims[1]], sample[dims[2]]]); const shouldLogDetails = (test < 1 || test >= config.tests - 1) && document.getElementById('showConsole').checked; if (shouldLogDetails) console.log(`\nTest #${test + 1}: Dims ${dims.join(', ')}`); else if (test === 1 && config.tests > 2 && document.getElementById('showConsole').checked) console.log(`... (omitting details for tests 2 to ${config.tests - 1}) ...`); const fitResult = fitEllipsoid(projection, shouldLogDetails); if (fitResult && typeof fitResult.mse === 'number' && isFinite(fitResult.mse)) { mseValues.push(fitResult.mse); if (shouldLogDetails) console.log(` Fit OK. MSE: ${fitResult.mse.toFixed(6)}`); projectionForVis = { projection: projection.slice(0, VISUALIZATION_POINTS), center: fitResult.center, radii: fitResult.radii, rotation: fitResult.rotation }; } else { if(shouldLogDetails) console.warn(`Test #${test + 1}: Ellipsoid fitting failed or returned invalid MSE. Assigning MSE=1.`); mseValues.push(1.0); chunkFailedFits++; } } testsDone = chunkEndIdx; const elapsed = Date.now() - start; console.log(` Processed tests ${chunkStartIdx + 1}-${chunkEndIdx} (${chunkFailedFits} failed fits) in ${elapsed}ms.`); if (testsDone < config.tests) { setTimeout(processChunk, 0); } else { processTestResults(type, mseValues, config.tests); if (projectionForVis) { currentProjection = projectionForVis; updateVisualization(); } else { console.warn("No valid projections fit; 3D visualization skipped."); clearVisualization(); } loading.classList.add('hidden'); loading.style.opacity = 0; showToast(`${datasetName} testing complete.`, 'success'); } } setTimeout(processChunk, 50); }
        function processTestResults(type, mseValues, numTestsRun) { /* ... replaces alert with showToast ... */ const validMSEs = mseValues.filter(mse => typeof mse === 'number' && isFinite(mse)); if (validMSEs.length === 0) { console.error("No valid MSE values collected."); showToast(`Testing failed for ${type}: No valid fits obtained.`, 'error'); return; } if (validMSEs.length < numTestsRun) { console.warn(`Only ${validMSEs.length} / ${numTestsRun} tests yielded valid MSE values.`); showToast(`Warning: ${numTestsRun - validMSEs.length} tests failed to fit. Results based on ${validMSEs.length} tests.`, 'warning'); } const mean = calculateMean(validMSEs); const stdDev = calculateStdDev(validMSEs, mean); const results = { type, mseValues: validMSEs, mean, stdDev, numTests: validMSEs.length }; const datasetName = type === 'uploaded' ? `UPLOADED (${uploadedDataInfo.name})` : type.toUpperCase(); console.log(`\n========== FINAL RESULTS FOR ${datasetName} ==========`); console.log(` Tests Completed (Valid Fits): ${validMSEs.length} / ${numTestsRun}`); console.log(` Mean MSE: ${mean.toFixed(6)}`); console.log(` Std Dev MSE: ${stdDev.toFixed(6)}`); if (type === 'normal') { normalResults = results; updateResultDisplay('normal', results); updateHistogram('normal', validMSEs); console.log(` Interpretation: This is the reference distribution for normal data.`); } else { nonNormalResults = results; updateResultDisplay('nonNormal', results); updateHistogram('nonNormal', validMSEs); console.log(` Interpretation: Compare this distribution to the reference Normal.`); } console.log(` Click "Compare & Conclude" (if applicable) or "New Projection" to explore.`); }

        // --- Ellipsoid Fitting (getRandomDimensions, fitEllipsoid) ---
        // ... (Unchanged from previous version) ...
        function getRandomDimensions(maxDim, count) { const dims = new Set(); if (count > maxDim) return Array.from({length: maxDim}, (_, i) => i); while (dims.size < count) { dims.add(Math.floor(Math.random() * maxDim)); } return Array.from(dims); }
        function fitEllipsoid(points, logDetails = false) { const n = points.length; if (!points || n < 4) { if (logDetails) console.warn("Need at least 4 points to fit ellipsoid."); return null; } try { let center = [0, 0, 0]; let validPointsCount = 0; for (const p of points) { if (!p || p.length !== 3 || !isFinite(p[0]) || !isFinite(p[1]) || !isFinite(p[2])) { if (logDetails && validPointsCount < 5) console.warn("Skipping invalid point:", p); continue; } center[0] += p[0]; center[1] += p[1]; center[2] += p[2]; validPointsCount++; } if (validPointsCount < 4) { if (logDetails) console.warn(`Only ${validPointsCount} valid points found, insufficient for fitting.`); return null; } center = center.map(c => c / validPointsCount); if (!isFinite(center[0]) || !isFinite(center[1]) || !isFinite(center[2])) { if (logDetails) console.error("Calculated center is NaN/Infinity."); return null; } const centeredPoints = points.filter(p => p && p.length === 3 && isFinite(p[0]) && isFinite(p[1]) && isFinite(p[2])).map(p => [p[0] - center[0], p[1] - center[1], p[2] - center[2]]); let covMatrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]; for (const p of centeredPoints) { for (let i = 0; i < 3; i++) { for (let j = 0; j < 3; j++) { covMatrix[i][j] += p[i] * p[j]; } } } covMatrix = numeric.div(covMatrix, validPointsCount); for (let i = 0; i < 3; i++) { for (let j = i + 1; j < 3; j++) { const avg = (covMatrix[i][j] + covMatrix[j][i]) / 2; covMatrix[i][j] = covMatrix[j][i] = avg; } covMatrix[i][i] += 1e-7; if (!isFinite(covMatrix[i][i])) { if (logDetails) console.error(`Covariance matrix element [${i},${i}] became non-finite.`); return null; } } let eigResult; try { eigResult = numeric.eig(covMatrix); if (!eigResult?.lambda?.x || !eigResult?.E?.x) throw new Error("Invalid structure from numeric.eig"); if (eigResult.lambda.y && eigResult.lambda.y.some(im => Math.abs(im) > 1e-6)) { if (logDetails) console.warn("Complex eigenvalues found, using real parts."); } } catch (eigError) { if (logDetails) console.error("Eigendecomposition failed:", eigError); return null; } const eigenvalues = eigResult.lambda.x.map(v => Math.max(v, 1e-9)); const scaleFactor = 2.5; const radii = eigenvalues.map(v => Math.sqrt(v) * scaleFactor); if (radii.some(r => !isFinite(r) || r <= 0)) { if (logDetails) console.error("Invalid radii calculated:", radii); return null; } const eVecs = eigResult.E.x; const rotation = [ [eVecs[0][0], eVecs[1][0], eVecs[2][0]], [eVecs[0][1], eVecs[1][1], eVecs[2][1]], [eVecs[0][2], eVecs[1][2], eVecs[2][2]] ]; let mseSum = 0; let mseCount = 0; const invRadiiSq = radii.map(r => 1 / (r * r)); for (const p of centeredPoints) { const pTransformed = [ rotation[0][0] * p[0] + rotation[1][0] * p[1] + rotation[2][0] * p[2], rotation[0][1] * p[0] + rotation[1][1] * p[1] + rotation[2][1] * p[2], rotation[0][2] * p[0] + rotation[1][2] * p[1] + rotation[2][2] * p[2] ]; const distSq = (pTransformed[0] * pTransformed[0]) * invRadiiSq[0] + (pTransformed[1] * pTransformed[1]) * invRadiiSq[1] + (pTransformed[2] * pTransformed[2]) * invRadiiSq[2]; if (isFinite(distSq) && distSq >= 0) { const error = Math.sqrt(distSq) - 1.0; mseSum += error * error; mseCount++; } else { if (logDetails && mseCount < 5) console.warn("Skipping point due to invalid transformed distance:", distSq); } } const mse = (mseCount > 0) ? mseSum / mseCount : Infinity; if (!isFinite(mse)) { if (logDetails) console.error("Final MSE is not finite:", mse); return null; } return { center, radii, rotation, mse }; } catch (error) { console.error("Unexpected error during ellipsoid fitting:", error); return null; } }

        // --- Visualization ---
        // ... (updateVisualization, clearVisualization, fitCameraToObject unchanged from previous) ...
        function updateVisualization() { if (!scene || !camera || !renderer) { console.error("3D Scene not ready."); return; } if (!currentProjection?.projection?.length) { console.log("No projection data to visualize."); clearVisualization(); return; } console.log("Updating 3D visualization..."); clearVisualization(); try { const pointsData = currentProjection.projection; const positions = new Float32Array(pointsData.length * 3); let i = 0; for (const p of pointsData) { positions[i++] = p[0]; positions[i++] = p[1]; positions[i++] = p[2]; } const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.computeBoundingSphere(); const material = new THREE.PointsMaterial({ color: 0x3b82f6, size: 0.06, sizeAttenuation: true }); pointsObj = new THREE.Points(geometry, material); scene.add(pointsObj); const { center, radii, rotation } = currentProjection; const safeRadii = radii.map(r => Math.max(Math.abs(r), 1e-6)); const ellipsoidGeometry = new THREE.SphereGeometry(1, 32, 16); const ellipsoidMaterial = new THREE.MeshPhongMaterial({ color: 0xf97316, opacity: 0.35, transparent: true, depthWrite: false, side: THREE.DoubleSide }); ellipsoidMesh = new THREE.Mesh(ellipsoidGeometry, ellipsoidMaterial); ellipsoidMesh.position.set(center[0], center[1], center[2]); ellipsoidMesh.scale.set(safeRadii[0], safeRadii[1], safeRadii[2]); const rotationMatrix = new THREE.Matrix4().set( rotation[0][0], rotation[0][1], rotation[0][2], 0, rotation[1][0], rotation[1][1], rotation[1][2], 0, rotation[2][0], rotation[2][1], rotation[2][2], 0, 0, 0, 0, 1 ); ellipsoidMesh.rotation.setFromRotationMatrix(rotationMatrix); scene.add(ellipsoidMesh); fitCameraToObject(camera, pointsObj, 1.4); } catch (error) { console.error("Error updating visualization content:", error); clearVisualization(); showToast("Error updating 3D view.", "error"); } }
        function clearVisualization() { if (pointsObj) { scene.remove(pointsObj); pointsObj.geometry.dispose(); pointsObj.material.dispose(); pointsObj = null; } if (ellipsoidMesh) { scene.remove(ellipsoidMesh); ellipsoidMesh.geometry.dispose(); ellipsoidMesh.material.dispose(); ellipsoidMesh = null; } }
        function fitCameraToObject(camera, object, offset = 1.2) { if (!object || !object.geometry || !object.geometry.boundingSphere) { camera.position.set(0, 0, 5); camera.lookAt(scene.position); console.warn("Cannot fit camera: Invalid object or missing bounding sphere. Resetting view."); return; } const boundingSphere = object.geometry.boundingSphere; const center = boundingSphere.center.clone().applyMatrix4(object.matrixWorld); const radius = boundingSphere.radius * Math.max(object.scale.x, object.scale.y, object.scale.z); if (!isFinite(center.x) || !isFinite(radius) || radius <= 0) { camera.position.set(0, 0, 5); camera.lookAt(scene.position); console.warn("Cannot fit camera: Invalid bounding sphere data. Resetting view."); return; } const size = radius * 2; const fov = camera.fov * (Math.PI / 180); const cameraDistance = Math.abs(size / (2 * Math.tan(fov / 2))); const direction = camera.position.clone().sub(center).normalize(); const newPosition = center.clone().add(direction.multiplyScalar(cameraDistance * offset)); camera.position.copy(newPosition); camera.lookAt(center); camera.updateProjectionMatrix(); }
        function generateNewProjection() { /* ... replaces alert with showToast ... */ if (!currentDataset || currentDataset.length === 0 || !currentDatasetType) { showToast('Please generate/upload and test a dataset first!', 'warning'); return; } console.log(`\nGenerating new random projection for ${currentDatasetType}...`); const datasetDims = currentDataset[0].length; if (datasetDims < 3) { showToast("Dataset has fewer than 3 dimensions.", 'error'); return; } const dims = getRandomDimensions(datasetDims, 3); console.log(`Selected dimensions: ${dims.join(', ')}`); const projectionData = currentDataset.map(sample => [sample[dims[0]], sample[dims[1]], sample[dims[2]]]); const fitResult = fitEllipsoid(projectionData, false); if (fitResult && typeof fitResult.mse === 'number' && isFinite(fitResult.mse)) { currentProjection = { projection: projectionData.slice(0, VISUALIZATION_POINTS), center: fitResult.center, radii: fitResult.radii, rotation: fitResult.rotation }; console.log(`New projection MSE: ${fitResult.mse.toFixed(6)}`); updateVisualization(); showToast(`Generated new projection. MSE: ${fitResult.mse.toFixed(4)}`, 'info'); } else { console.error("Failed to fit ellipsoid for new projection view."); showToast("Failed to generate new projection view. Fit failed.", 'error'); clearVisualization(); } }

        function updateHistogram(type, mseValues) { /* ... unchanged ... */ const chart = histogramCharts[type]; if (!chart) { console.error(`Histogram chart type '${type}' not found.`); return; } if (!mseValues || mseValues.length === 0) { chart.data.labels = []; chart.data.datasets[0].data = []; chart.update(); return; } const min = Math.min(...mseValues); const max = Math.max(...mseValues); const binCount = 20; const binWidth = (max - min < 1e-9) ? 0.01 : (max - min) / binCount; const bins = new Array(binCount).fill(0); const labels = new Array(binCount); for (let i = 0; i < binCount; i++) { const binStart = min + i * binWidth; const binEnd = binStart + binWidth; labels[i] = `${binStart.toFixed(3)}-${binEnd.toFixed(3)}`; } for (const mse of mseValues) { let binIndex = 0; if (binWidth > 1e-9) { binIndex = Math.floor((mse - min) / binWidth); } binIndex = Math.max(0, Math.min(binIndex, binCount - 1)); if (mse === max && binIndex < binCount -1 && binWidth > 1e-9) binIndex = binCount - 1; bins[binIndex]++; } chart.data.labels = labels; chart.data.datasets[0].data = bins; chart.update(); console.log(`Histogram updated for type: ${type}.`); }

        // --- Comparison and Conclusion ---
        function compareAndConclude() { /* ... replaces alert with showToast ... */ if (!normalResults) { showToast('Reference Normal dataset results missing. Please test it first.', 'warning'); return; } if (!nonNormalResults) { showToast('Test dataset (Non-Normal or Uploaded) results missing. Please test one first.', 'warning'); return; } const compareTarget = nonNormalResults.type === 'uploaded' ? `Uploaded (${uploadedDataInfo.name})` : 'Non-Normal'; console.log(`\n========== COMPARATIVE ANALYSIS: Normal vs ${compareTarget} ==========`); try { const uTestResult = mannWhitneyUTest(normalResults.mseValues, nonNormalResults.mseValues); if (!uTestResult) throw new Error("Mann-Whitney U test failed."); console.log(`STATISTICAL TEST (Mann-Whitney U):`); console.log(` U-stat: ${uTestResult.U?.toFixed(2)}, Z-score: ${uTestResult.z?.toFixed(4)}, p-value: ${uTestResult.p?.toExponential(4)}`); const significance = uTestResult.p < 0.05 ? 'SIGNIFICANTLY different' : 'NOT significantly different'; console.log(` Result (=0.05): MSE distributions are ${significance}.`); const normalityScore = calculateNormalityScore(normalResults, nonNormalResults, uTestResult); console.log(`CALCULATED NORMALITY SCORE for ${compareTarget}: ${normalityScore.toFixed(0)}% (higher = more normal-like)`); displayConclusion(normalityScore, normalResults, nonNormalResults, uTestResult); showToast('Comparison complete. Conclusion displayed below.', 'info'); } catch (error) { console.error("Error during comparison:", error); showToast("Failed comparison analysis: " + error.message, 'error'); clearConclusion(); } }
        function mannWhitneyUTest(arr1, arr2) { /* ... unchanged ... */ if (!arr1 || !arr2 || arr1.length < 3 || arr2.length < 3) { console.warn("Mann-Whitney U Test requires two arrays with at least 3 elements each."); return { U: NaN, z: NaN, p: 1.0, error: "Insufficient data" }; } try { const n1 = arr1.length; const n2 = arr2.length; const N = n1 + n2; const combined = [ ...arr1.map(value => ({ value, group: 1 })), ...arr2.map(value => ({ value, group: 2 })) ].sort((a, b) => a.value - b.value); let ranks = { 1: 0, 2: 0 }; let tieCounts = {}; let i = 0; while (i < N) { let j = i; const currentValue = combined[i].value; while (j < N - 1 && combined[j + 1].value === currentValue) { j++; } const tiedCount = (j - i) + 1; const avgRank = (i + 1 + j + 1) / 2; if (tiedCount > 1) { tieCounts[currentValue] = tiedCount; } for (let k = i; k <= j; k++) { ranks[combined[k].group] += avgRank; } i = j + 1; } const R1 = ranks[1]; const R2 = ranks[2]; const U1 = R1 - (n1 * (n1 + 1)) / 2; const U2 = R2 - (n2 * (n2 + 1)) / 2; const U = Math.min(U1, U2); const meanU = (n1 * n2) / 2; let tieCorrection = 0; Object.values(tieCounts).forEach(t => { tieCorrection += (t * t * t - t); }); const varianceU = (n1 * n2 / (N * (N - 1))) * ((N * N * N - N - tieCorrection) / 12); const stdU = Math.sqrt(Math.max(varianceU, 1e-9)); let z = 0; if (stdU > 1e-9) { z = (U - meanU + (U < meanU ? -0.5 : 0.5)) / stdU; } const p = 2 * (1 - standardNormalCDF(Math.abs(z))); return { U, z, p }; } catch (error) { console.error("Error in mannWhitneyUTest:", error); return null; } }
        function standardNormalCDF(x) { /* ... unchanged ... */ const p = 0.2316419; const b = [0, 0.319381530, -0.356563782, 1.781477937, -1.821255978, 1.330274429]; const t = 1 / (1 + p * Math.abs(x)); const Z = (1 / Math.sqrt(2 * Math.PI)) * Math.exp(-x * x / 2); let y = 1 - Z * t * (b[1] + t * (b[2] + t * (b[3] + t * (b[4] + t * b[5])))); return x > 0 ? y : 1 - y; }
        function calculateNormalityScore(normRes, nonNormRes, testRes) { /* ... unchanged from previous refinement ... */ if (!normRes || !nonNormRes || !testRes || !isFinite(testRes.p)) return 50; let score = 50.0; const epsilon = 1e-9; const meanRatio = nonNormRes.mean / (normRes.mean + epsilon); const stdDevRatio = nonNormRes.stdDev / (normRes.stdDev + epsilon); const pValue = testRes.p; /* Mean MSE Ratio (Weight: ~30 points) */ if (meanRatio > 4) score -= 30; else if (meanRatio > 2.5) score -= 20; else if (meanRatio > 1.5) score -= 10; else if (meanRatio < 0.8) score += 5; /* Std Dev MSE Ratio (Weight: ~25 points) */ if (stdDevRatio > 3) score -= 25; else if (stdDevRatio > 2) score -= 15; else if (stdDevRatio > 1.5) score -= 10; else if (stdDevRatio < 0.7) score += 5; /* P-value (Weight: ~45 points) */ if (pValue < 0.0001) score -= 45; else if (pValue < 0.001) score -= 35; else if (pValue < 0.01) score -= 25; else if (pValue < 0.05) score -= 20; else if (pValue > 0.3) score += 5; else if (pValue > 0.6) score += 10; return Math.max(0, Math.min(100, Math.round(score))); }
        function displayConclusion(normalityScore, normRes, nonNormRes, testRes) { /* ... Refined text ... */ const container = document.getElementById('conclusionContainer'); if (!container) return; container.innerHTML = ''; const conclusionDiv = document.createElement('div'); conclusionDiv.className = 'bg-white p-4 md:p-6 rounded-lg shadow-md animate-fade-in'; let conclusionText, panelColorClass, confidenceText; const compareTargetName = nonNormRes.type === 'uploaded' ? `Uploaded (${uploadedDataInfo.name})` : 'Non-Normal'; if (normalityScore >= 80) { conclusionText = `appears <strong>CONSISTENT</strong> with the reference`; panelColorClass = 'border-green-500 bg-green-50'; confidenceText = 'High Confidence'; } else if (normalityScore >= 55) { conclusionText = `shows <strong>SOME SIMILARITY</strong> to the reference, but potential deviations exist`; panelColorClass = 'border-lime-500 bg-lime-50'; confidenceText = 'Moderate Confidence'; } else if (normalityScore >= 30) { conclusionText = `shows <strong>MODERATE DEVIATIONS</strong> from the reference`; panelColorClass = 'border-yellow-500 bg-yellow-50'; confidenceText = 'Moderate Confidence'; } else { conclusionText = `appears <strong>STRONGLY INCONSISTENT</strong> with the reference`; panelColorClass = 'border-red-500 bg-red-50'; confidenceText = 'High Confidence'; } const formatNum = (num, prec = 6) => (typeof num === 'number' && isFinite(num)) ? num.toFixed(prec) : '-'; const formatPval = (p) => (typeof p === 'number' && isFinite(p)) ? (p < 0.001 ? p.toExponential(2) : p.toFixed(4)) : '-'; const pValSignificance = (p) => (typeof p !== 'number' || !isFinite(p)) ? '' : (p < 0.05 ? '<span class="font-semibold text-red-600">(Significant Diff.)</span>' : '<span class="text-green-600">(Not Signif. Diff.)</span>'); const mseRatio = normRes.mean > 1e-9 ? nonNormRes.mean / normRes.mean : NaN; const stdRatio = normRes.stdDev > 1e-9 ? nonNormRes.stdDev / normRes.stdDev : NaN; conclusionDiv.innerHTML = ` <h2 class="text-xl font-semibold mb-4 text-gray-800">Analysis Conclusion: Reference Normal vs ${compareTargetName}</h2> <div class="border-l-4 ${panelColorClass} pl-4 py-3 rounded mb-5 text-gray-700"> <p class="font-medium text-base">The <strong>${compareTargetName}</strong> dataset's MSE distribution ${conclusionText} Multivariate Normal distribution.</p> <p class="text-sm mt-1">Heuristic Normality Likelihood Score (Relative to Ref.): <strong class="text-lg">${normalityScore}%</strong> (${confidenceText})</p> </div> <h4 class="font-semibold mb-2 text-gray-800">Comparative Metrics:</h4> <div class="overflow-x-auto mb-4"> <table class="min-w-full divide-y divide-gray-200 text-sm border border-gray-200"> <thead class="bg-gray-50"><tr> <th class="px-3 py-2 text-left font-medium text-gray-600 uppercase tracking-wider">Metric</th> <th class="px-3 py-2 text-right font-medium text-gray-600 uppercase tracking-wider">Normal (Ref)</th> <th class="px-3 py-2 text-right font-medium text-gray-600 uppercase tracking-wider">${nonNormRes.type === 'uploaded' ? 'Uploaded' : 'Non-Normal'}</th> <th class="px-3 py-2 text-right font-medium text-gray-600 uppercase tracking-wider">Ratio</th> </tr></thead> <tbody class="bg-white divide-y divide-gray-200"> <tr><td class="px-3 py-2 font-medium text-gray-800">Mean MSE</td><td class="px-3 py-2 text-right text-gray-700 font-mono">${formatNum(normRes.mean)}</td><td class="px-3 py-2 text-right text-gray-700 font-mono">${formatNum(nonNormRes.mean)}</td><td class="px-3 py-2 text-right text-gray-700 font-mono ${mseRatio > 1.5 ? 'text-red-600' : (mseRatio < 0.9 ? 'text-green-600' : '')}">${formatNum(mseRatio, 2)}x</td></tr> <tr><td class="px-3 py-2 font-medium text-gray-800">Std Dev MSE</td><td class="px-3 py-2 text-right text-gray-700 font-mono">${formatNum(normRes.stdDev)}</td><td class="px-3 py-2 text-right text-gray-700 font-mono">${formatNum(nonNormRes.stdDev)}</td><td class="px-3 py-2 text-right text-gray-700 font-mono ${stdRatio > 1.5 ? 'text-red-600' : (stdRatio < 0.9 ? 'text-green-600' : '')}">${formatNum(stdRatio, 2)}x</td></tr> <tr><td class="px-3 py-2 font-medium text-gray-800">M-W U Test (p-value)</td><td class="px-3 py-2 text-right text-gray-700">-</td><td class="px-3 py-2 text-right text-gray-700">-</td><td class="px-3 py-2 text-right text-gray-700 font-mono">${formatPval(testRes.p)} ${pValSignificance(testRes.p)}</td></tr> </tbody> </table> </div> <div class="bg-blue-50 border border-blue-200 text-blue-800 px-4 py-3 rounded relative text-sm" role="alert"> <strong class="font-bold">Interpretation Help:</strong> <span class="block sm:inline"> The Mann-Whitney U test checks if the MSE distributions are statistically different. A low p-value (< 0.05) suggests the test dataset significantly deviates from the reference Normal distribution in terms of projection fit errors. Higher Mean/StdDev MSE ratios also indicate greater deviation. The Normality Score is a heuristic summary based on these comparisons.</span> </div> `; container.appendChild(conclusionDiv); container.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); console.log("Conclusion panel displayed."); }
        function clearConclusion() { /* ... unchanged ... */ const container = document.getElementById('conclusionContainer'); if (container) container.innerHTML = ''; }
        function updateResultDisplay(type, results) { /* ... unchanged from previous refinement ... */ const prefix = type === 'normal' ? 'normal' : 'nonNormal'; const meanEl = document.getElementById(`${prefix}MeanMSE`); const stdEl = document.getElementById(`${prefix}StdMSE`); const formatNum = (num, prec = 6) => (typeof num === 'number' && isFinite(num)) ? num.toFixed(prec) : '-'; if (results && meanEl && stdEl) { meanEl.textContent = formatNum(results.mean); stdEl.textContent = formatNum(results.stdDev); meanEl.className = `text-xl font-semibold font-mono ${results.mean > 0.15 ? 'text-red-600' : (results.mean < 0.05 ? 'text-green-600' : 'text-gray-900')}`; stdEl.className = `text-xl font-semibold font-mono ${results.stdDev > 0.08 ? 'text-red-600' : (results.stdDev < 0.02 ? 'text-green-600' : 'text-gray-900')}`; } else if (meanEl && stdEl) { meanEl.textContent = '-'; stdEl.textContent = '-'; meanEl.className = 'text-xl font-semibold font-mono text-gray-900'; stdEl.className = 'text-xl font-semibold font-mono text-gray-900'; } }

        // --- Helper Functions ---
        function calculateMean(arr) { /* ... unchanged ... */ if (!arr || arr.length === 0) return NaN; return arr.reduce((sum, val) => sum + val, 0) / arr.length; }
        function calculateStdDev(arr, mean) { /* ... unchanged ... */ if (!arr || arr.length === 0) return NaN; if (mean === undefined || isNaN(mean)) mean = calculateMean(arr); if (isNaN(mean)) return NaN; const variance = arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length; return Math.sqrt(variance); }

    </script>

</body>
</html>